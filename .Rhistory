#Create a retuns vector based on opaning cna closing prices
ret.spy=Delt(Op(x = GSPC),Cl(x = GSPC))
# Signal Vector based on the prce changes increase => 1 else 0 and lag it by one period
sgnl.spy=lag(ifelse(Cl(GSPC)>Op(GSPC),1,0),1)
#performance matrix by multiplying returns to signal
strat.perf=ret.spy*sgnl.spy
#check the cumulative return??
#try another signal
sgnl.spy2=ifelse(((Cl(GSPC)>Op(GSPC))),1,0)*
ifelse(lag(Cl(GSPC),1)>lag(Op(GSPC),1),1,0)*
ifelse(lag(Cl(GSPC),2)>lag(Op(GSPC),2),1,0)
#number of trades
sum(sgnl.spy2)
#plot performance summary
charts.PerformanceSummary(ret.spy*sgnl.spy2)
#Using SMA
sma.spy.30d.hi=SMA(Hi(GSPC),30)
sma.spy.30d.lo=SMA(Lo(GSPC),30)
sgnl.spy3=lag(ifelse(Cl(GSPC)>sma.spy.30d.hi,1,0)+ifelse(Cl(GSPC)<sma.spy.30d.lo,-1,0),1)
#remove NAs
sgnl.spy3[is.na(sgnl.spy3)]=0
?Delt
?lag
####Changepoint Analysis
# install.packages('changepoint')
library(changepoint)
# install quantmod
# install.packages('quantmod')
library(quantmod)
#Norm Func's
nrmw.stk=function(x,y) {
tmp1=to.weekly(x)
names(tmp1)=c("op", "hi", "lo", "cl", "vo", "ad")
tmp2=last(tmp1,y)
tmp1=tmp2$cl/max(tmp2$hi)
return(tmp1)
}
nrmw.com=function(x,y){
tmp1=to.weekly(x)
names(tmp1)=c("op", "hi", "lo", "cl")
tmp2=last(tmp1,y)
tmp1=tmp2$cl/max(tmp2$hi)
return(tmp1)
}
#Get Some Data
getSymbols("XAU/USD", src="oanda")
gldnw=nrmw.com(XAUUSD,0)
#Change point for gld using
#need to fix the date formatting somehow
#MeanVar and PELT
chg.gld=cpt.meanvar(head
(as.ts(gldnw,
start=head(index(gldnw),1),
end=tail(index(gldnw),1)),
length(gldnw)),
method='PELT')
plot(chg.gld)
#get changepoints index values
cpts(chg.gld)
#extract dates from the index values
na.omit(index(gldnw)[cpts(chg.gld)])
#test for FRED's data
getSymbols('GOLDPMGBD228NLBM',src='FRED')
getSymbols('DJIA',src='FRED')
# this isnt working (err: missing values, most likely due to uneven time periods)
chg.gld2=cpt.meanvar(head(
na.exclude(as.ts(
to.yearly(GOLDPMGBD228NLBM),
start=head(index(to.yearly(GOLDPMGBD228NLBM)),1),
end=tail(index(to.yearly(GOLDPMGBD228NLBM)),1))),
length(na.exclude(to.yearly(GOLDPMGBD228NLBM)))),
method='PELT')
plot(chg.gld2)
?diff.Date
diff.Date(na.omit(index(gldnw)[cpts(chg.gld)]))
plot(x=na.omit(index(gldnw)[cpts(chg.gld)]), y=diff.Date(na.omit(index(gldnw)[cpts(chg.gld)])))
plot(na.omit(index(gldnw)[cpts(chg.gld)]), diff.Date(na.omit(index(gldnw)[cpts(chg.gld)])))
sum(na.omit(index(gldnw)[cpts(chg.gld)]))
index(gldnw)
17/71
library(deplyr)
install.packages('dplyr')
library(dplyr)
version()
R.version()
?version()
R.version.string()
install.packages('dplyr')
install.packages('dplyr')
?diff
#Trading Strategy 1
#Shamelessly Copied from:
#http://blog.fosstrading.com/search/label/Examples
library(PerformanceAnalytics)
library(quantmod)
#Get Some Data
getSymbols("^GSPC", src = "yahoo")
getSymbols('DJIA',src='FRED')
getSymbols('SP500',src='FRED')
#Buy low sell high
#Create a retuns vector based on opaning cna closing prices
ret.spy=Delt(Op(x = GSPC),Cl(x = GSPC))
# Signal Vector based on the prce changes increase => 1 else 0 and lag it by one period
sgnl.spy=lag(ifelse(Cl(GSPC)>Op(GSPC),1,0),1)
#performance matrix by multiplying returns to signal
strat.perf=ret.spy*sgnl.spy
#check the cumulative return??
#try another signal
sgnl.spy2=ifelse(((Cl(GSPC)>Op(GSPC))),1,0)*
ifelse(lag(Cl(GSPC),1)>lag(Op(GSPC),1),1,0)*
ifelse(lag(Cl(GSPC),2)>lag(Op(GSPC),2),1,0)
#number of trades
sum(sgnl.spy2)
#plot performance summary
charts.PerformanceSummary(ret.spy*sgnl.spy2)
#Using SMA
sma.spy.30d.hi=SMA(Hi(GSPC),30)
sma.spy.30d.lo=SMA(Lo(GSPC),30)
sgnl.spy3=lag(ifelse(Cl(GSPC)>sma.spy.30d.hi,1,0)+ifelse(Cl(GSPC)<sma.spy.30d.lo,-1,0),1)
#remove NAs
sgnl.spy3[is.na(sgnl.spy3)]=0
plot(diff(GSPC))
plot(diff(to.weekly(GSPC)))
library(changepoint)
?ClCl
plot(Delt(Cl(GSPC),Cl(GSPC),k=1,type = 'arithmetic'))
plot(Delt(Cl(to.weekly(GSPC)),Cl(to.weekly(GSPC)),k=1,type = 'arithmetic'))
#Norm funcs
nrmw.stk=function(x,y) {
tmp1=to.weekly(x)
names(tmp1)=c("op", "hi", "lo", "cl", "vo", "ad")
tmp2=last(tmp1,y)
tmp1=tmp2$cl/max(tmp2$hi)
return(tmp1)
}
nrmw.com=function(x,y){
tmp1=to.weekly(x)
names(tmp1)=c("op", "hi", "lo", "cl")
tmp2=last(tmp1,y)
tmp1=tmp2$cl/max(tmp2$hi)
return(tmp1)
}
#
#Download Data
# install quantmod
#install.packages('quantmod')
library(quantmod)
getSymbols("XAU/USD", src="oanda")
getSymbols("XAG/USD", src="oanda")
getSymbols("XPT/USD", src="oanda")
getSymbols("XCU/USD", src="oanda")
getSymbols("EUR/USD",src="oanda")
getSymbols("INR/USD",src="oanda")
getSymbols("CNY/USD",src="oanda")
getSymbols("JPY/USD",src="oanda")
getSymbols("BRL/USD",src="oanda")
getSymbols("RUB/USD", src="oanda")
getSymbols("^GSPC", src = "yahoo")
getSymbols('DJIA',src='FRED')
getSymbols('SP500',src='FRED')
gldnw=nrmw.com(XAUUSD,0)
slvnw=nrmw.com(XAGUSD,0)
pltnw=nrmw.com(XPTUSD,0)
eurnw=nrmw.com(EURUSD,0)
inrnw=nrmw.com(INRUSD,0)
cnynw=nrmw.com(CNYUSD,0)
brlnw=nrmw.com(BRLUSD,0)
rubnw=nrmw.com(RUBUSD,0)
spxnw=nrmw.stk(GSPC,length(gldnw))
leg=c("au","ag","pt","eur","inr","cny","brl","rub","sp500")
limy=c(0.45,1.1)
plot(gldnw,ylim=limy)
lines(slvnw,col=2)
lines(pltnw,col=3)
lines(eurnw,col=4)
lines(inrnw,col=5)
lines(cnynw,col=6)
lines(brlnw,col=7)
lines(rubnw,col=8)
lines(spxnw,col=9,lty=5,lwd=2)
legend("topleft",leg,text.col=c(1:9),horiz=TRUE)
head(gldnw)
plot(Delt(gldnw,gldnw,k=1,type = 'arithmetic'))
####Changepoint Analysis
# install.packages('changepoint')
library(changepoint)
# install quantmod
# install.packages('quantmod')
library(quantmod)
#Norm Func's
nrmw.stk=function(x,y) {
tmp1=to.weekly(x)
names(tmp1)=c("op", "hi", "lo", "cl", "vo", "ad")
tmp2=last(tmp1,y)
tmp1=tmp2$cl/max(tmp2$hi)
return(tmp1)
}
nrmw.com=function(x,y){
tmp1=to.weekly(x)
names(tmp1)=c("op", "hi", "lo", "cl")
tmp2=last(tmp1,y)
tmp1=tmp2$cl/max(tmp2$hi)
return(tmp1)
}
#Get Some Data
getSymbols("XAU/USD", src="oanda")
gldnw=nrmw.com(XAUUSD,0)
#Change point for gld using
#need to fix the date formatting somehow
#MeanVar and PELT
chg.gld=cpt.meanvar(head
(as.ts(gldnw,
start=head(index(gldnw),1),
end=tail(index(gldnw),1)),
length(gldnw)),
method='PELT')
plot(chg.gld)
#get changepoints index values
cpts(chg.gld)
#extract dates from the index values
na.omit(index(gldnw)[cpts(chg.gld)])
#test for FRED's data
getSymbols('GOLDPMGBD228NLBM',src='FRED')
getSymbols('DJIA',src='FRED')
# this isnt working (err: missing values, most likely due to uneven time periods)
chg.gld2=cpt.meanvar(head(
na.exclude(as.ts(
to.yearly(GOLDPMGBD228NLBM),
start=head(index(to.yearly(GOLDPMGBD228NLBM)),1),
end=tail(index(to.yearly(GOLDPMGBD228NLBM)),1))),
length(na.exclude(to.yearly(GOLDPMGBD228NLBM)))),
method='PELT')
plot(chg.gld2)
install.packages('tsDyn' 'tseriesChaos')
install.packages('tsDyn','tseriesChaos')
library(tsDyn)
library(tseriesChaos)
box(spxnw)
autopairs(gldnw,lag = 1,type = 'regression')
install.packages('sm')
autopairs(gldnw,lag = 1,type = 'regression')
autopairs(gldnw,lag = 3,type = 'regression')
autopairs(gldnw,lag = 3,type = 'regression')
?acf
acf(gldnw)
mutual(gldnw)
?mutual()
recurr(series = gldnw,m = 3,d = 1,levels=c(0,0.2,1))
recurr(series = gldnw,m = 3,d = 1,levels=c(0,0.4,1))
?recurr(series = gldnw,m = 3,d = 1,levels=c(0,0.4,1))
lag.plot(gldnw,lags=3,layout = c(1,3))
delta.test(gldnw)
modl.ar = linear(gldnw,m=2)
modl.ar
modl.ar = linear(gldnw,m=3)
modl.ar
modl.2ar = linear(gldnw,m=2)
modl.3ar = linear(gldnw,m=3)
?setar
list()
?list()
?lstar
?setar
mod.setar=setar(gldnw,m = 2,mL = 2,mH = 2,thDelay = 1)
?setar
?lstar
mod.setar=setar(gldnw,m = 2,thDelay = 1)
mod.lstar=lstar(gldnw,m = 2,thDelay = 1)
?nnetTs
?aar
mod.setar=setar(gldnw,m = 2,thDelay = 1)
#Logistic Smooth Transition AutoRegressive model
mod.lstar=lstar(gldnw,m = 2,thDelay = 1)
#Neural Network nonlinear autoregressive model
mod.nnetts=nnetTs(gldnw,m = 2,size = 3)
#Additive nonlinear autoregressive model
mod.aar=aar(x,m = 2)
#linear 2 parameter
modl.2ar = linear(gldnw,m=2)
#linear 3 parameter
modl.3ar = linear(gldnw,m=3)
#Self Threshold, autoregressive (setar)
modl.setar=setar(gldnw,m = 2,thDelay = 1)
#Logistic Smooth Transition AutoRegressive model
modl.lstar=lstar(gldnw,m = 2,thDelay = 1)
#Neural Network nonlinear autoregressive model
modl.nnetts=nnetTs(gldnw,m = 2,size = 3)
#Additive nonlinear autoregressive model
modl.aar=aar(x,m = 2)
modl.aar=aar(x,m = 2)
modl.aar=aar(gldnw,m = 2)
mod=list()
mod[["Linear 2args"]] = modl.2ar
mod[["Linear 3args"]] = modl.3ar
mod[["Self Thr Auto"]] = modl.setar
mod[["Lgst Smth Auto"]] = modl.lstar
mod[["Neural Net"]] = modl.nnetts
mod[["Addtv NL Auto"]] = modl.aar
sapply(mod,AIC)
sapply(mod,MAPE)
?AIC
sapply(mod,AIC)
sapply(mod,BIC)
min(sapply(mod,AIC))
max(sapply(mod,AIC))
index(max(sapply(mod,AIC)))
sapply(mod,AIC,BIC,MAPE)
sapply(mod,AIC)
sapply(mod,BIC)
sapply(mod,MAPE)
mod[1]
#Models and forecasting
#linear 2 parameter
modl.2ar = linear(gldnw,m=2)
#linear 3 parameter
modl.3ar = linear(gldnw,m=3)
#Self Threshold, autoregressive (setar)
modl.setar=setar(gldnw,m = 2,thDelay = 1)
#Logistic Smooth Transition AutoRegressive model
modl.lstar=lstar(gldnw,m = 2,thDelay = 1)
#Neural Network nonlinear autoregressive model
modl.nnetts=nnetTs(gldnw,m = 2,size = 3)
#Additive nonlinear autoregressive model
modl.aar=aar(gldnw,m = 2)
#create list of models for comparison
mod=list()
#Index 1
mod[["Linear 2args"]] = modl.2ar
#Index 2
mod[["Linear 3args"]] = modl.3ar
#Index 3
mod[["Self Thr Auto"]] = modl.setar
#Index 4
mod[["Lgst Smth Auto"]] = modl.lstar
#Index 5
mod[["Neural Net"]] = modl.nnetts
#Index 6
mod[["Addtv NL Auto"]] = modl.aar
# Compare using AIC and MAPE
sapply(mod,AIC)
sapply(mod,BIC)
sapply(mod,MAPE)
# find the best model based on the indicators
#AIC indicator
max(sapply(mod,AIC))
index(max(sapply(mod,AIC)))
mod[index(max(sapply(mod,AIC)))]
#BIC indicator
max(sapply(mod,BIC))
index(max(sapply(mod,BIC)))
mod[index(max(sapply(mod,BIC)))]
#MAPE
min(sapply(mod,MAPE))
index(min(sapply(mod,MAPE)))
mod[index(min(sapply(mod,MAPE)))]
sapply(mod,AIC)
sapply(mod,BIC)
sapply(mod,MAPE)
#Delta Test
delta.test(gldnw)
#Models and forecasting
#linear 2 parameter
modl.2ar = linear(gldnw,m=2)
#linear 3 parameter
modl.3ar = linear(gldnw,m=3)
#Self Threshold, autoregressive (setar)
modl.setar=setar(gldnw,m = 2,thDelay = 1)
#Logistic Smooth Transition AutoRegressive model
modl.lstar=lstar(gldnw,m = 2,thDelay = 1)
#Neural Network nonlinear autoregressive model
modl.nnetts=nnetTs(gldnw,m = 2,size = 3)
#Additive nonlinear autoregressive model
modl.aar=aar(gldnw,m = 2)
#create list of models for comparison
mod=list()
#Index 1
mod[["Linear 2args"]] = modl.2ar
#Index 2
mod[["Linear 3args"]] = modl.3ar
#Index 3
mod[["Self Thr Auto"]] = modl.setar
#Index 4
mod[["Lgst Smth Auto"]] = modl.lstar
#Index 5
mod[["Neural Net"]] = modl.nnetts
#Index 6
mod[["Addtv NL Auto"]] = modl.aar
# find the best model based on the indicators
#AIC indicator
max(sapply(mod,AIC))
index(max(sapply(mod,AIC)))
mod[index(max(sapply(mod,AIC)))]
#BIC indicator
max(sapply(mod,BIC))
index(max(sapply(mod,BIC)))
mod[index(max(sapply(mod,BIC)))]
#MAPE
min(sapply(mod,MAPE))
index(min(sapply(mod,MAPE)))
mod[index(min(sapply(mod,MAPE)))]
mod[index(max(sapply(mod,AIC)))]
sapply(mod,AIC)
modl.2ar
modl.aar
mod[index((sapply(mod,AIC)))]
index((sapply(mod,BIC)))
index(max(sapply(mod,BIC)))
str(mod)
head(mod)
mod.lst=c("Linear 2args", "Linear 3args","Self Thr Auto", "Lgst Smth Auto", "Neural Net", "Addtv NL Auto")
mod.list
mod.lst
mod.tabl = c(mod.lst,aic,bic,mape)
aic=sapply(mod,AIC)
bic=sapply(mod,BIC)
mape=sapply(mod,MAPE)
mod.tabl = c(mod.lst,aic,bic,mape)
mod.tabl
mod.tabl = c(mod.lst;aic;bic;mape)
mod.tabl = c(mod.lst,aic,bic,mape)
head(mod.tabl)
str(mod.tabl)
rm(mod.tabl)
table(mod.lst,aic,bic,mape)
tapply(mod.lst,aic,bic,mape)
bic
tapply(mod.lst,aic,bic,mape)
tapply(mod.lst,aic,mape)
tapply(mod.lst,aic)
str(bic)
#playing with a little chaos
#
#install.packages('tsDyn','tseriesChaos')
library(quantmod)
library(tsDyn)
library(tseriesChaos)
#Norm Func's
nrmw.stk=function(x,y) {
tmp1=to.weekly(x)
names(tmp1)=c("op", "hi", "lo", "cl", "vo", "ad")
tmp2=last(tmp1,y)
tmp1=tmp2$cl/max(tmp2$hi)
return(tmp1)
}
nrmw.com=function(x,y){
tmp1=to.weekly(x)
names(tmp1)=c("op", "hi", "lo", "cl")
tmp2=last(tmp1,y)
tmp1=tmp2$cl/max(tmp2$hi)
return(tmp1)
}
#Get Some Data
getSymbols("XAU/USD", src="oanda")
gldnw=nrmw.com(XAUUSD,0)
getSymbols('GOLDPMGBD228NLBM',src='FRED')
getSymbols('DJIA',src='FRED')
#plots
autopairs(gldnw,lag = 1,type = 'regression')
acf(gldnw)
mutual(gldnw)
recurr(series = gldnw,m = 3,d = 1,levels=c(0,0.2,1))
recurr(series = gldnw,m = 3,d = 1,levels=c(0,0.4,1))
lag.plot(gldnw,lags=3,layout = c(1,3))
#Delta Test
delta.test(gldnw)
#Models and forecasting
#linear 2 parameter
modl.2ar = linear(gldnw,m=2)
#linear 3 parameter
modl.3ar = linear(gldnw,m=3)
#Self Threshold, autoregressive (setar)
modl.setar=setar(gldnw,m = 2,thDelay = 1)
#Logistic Smooth Transition AutoRegressive model
modl.lstar=lstar(gldnw,m = 2,thDelay = 1)
#Neural Network nonlinear autoregressive model
modl.nnetts=nnetTs(gldnw,m = 2,size = 3)
#Additive nonlinear autoregressive model
modl.aar=aar(gldnw,m = 2)
#create list of models for comparison
mod=list()
#Index 1
mod[["Linear 2args"]] = modl.2ar
#Index 2
mod[["Linear 3args"]] = modl.3ar
#Index 3
mod[["Self Thr Auto"]] = modl.setar
#Index 4
mod[["Lgst Smth Auto"]] = modl.lstar
#Index 5
mod[["Neural Net"]] = modl.nnetts
#Index 6
mod[["Addtv NL Auto"]] = modl.aar
mod.lst=c("Linear 2args", "Linear 3args","Self Thr Auto", "Lgst Smth Auto", "Neural Net", "Addtv NL Auto")
# Compare using AIC and MAPE
aic=sapply(mod,AIC)
bic=sapply(mod,BIC)
mape=sapply(mod,MAPE)
#Table of Indicators
mod.tabl = c(mod.lst,aic,bic,mape)
# find the best model based on the indicators
#AIC indicator
max(sapply(mod,AIC))
#index((sapply(mod,AIC)))
#mod[index((sapply(mod,AIC)))]
#BIC indicator
max(sapply(mod,BIC))
#index((sapply(mod,BIC)))
#mod[index((sapply(mod,BIC)))]
#MAPE
min(sapply(mod,MAPE))
#index(min(sapply(mod,MAPE)))
#mod[index((sapply(mod,MAPE)))]
